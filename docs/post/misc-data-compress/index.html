<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
<title>数据压缩 101</title>



  




<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link
  rel="alternate"
  type="application/rss+xml"
  href="https://ixiaopan.github.io/blog/index.xml"
  title=""
/>

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="数据压缩 101"/>
<meta name="twitter:description" content="前几天得闲随手翻了翻 《数据压缩入门 - 豆瓣》，内容是比较浅显，但是真的要深入理解并应用这些算法还是有一定难度，印象比较深刻的是这3个算法

哈夫曼编码
算术编码
LZ编码

在实际应用中，这几个算法也是经常结合使用的，比如 gzip。"/>




<link rel="stylesheet" href="https://ixiaopan.github.io/blog/fontawesome/css/all.min.css" />




<link
  crossorigin="anonymous"
  href="/blog/css/styles.min.css"
  integrity=""
  rel="preload stylesheet"
  as="style"
/>


  <link rel="stylesheet" href="https://ixiaopan.github.io/blog/css/main.css" />



<link
  id="dark-mode-theme"
  crossorigin="anonymous"
  href="/blog/css/dark.min.css"
  integrity=""
  rel="preload stylesheet"
  as="style"
/>


<script>
  var darkTheme = document.getElementById('dark-mode-theme')
  var storedTheme = localStorage.getItem('dark-mode-storage')
  if (storedTheme === 'dark') {
    darkTheme.disabled = false
  } else if (storedTheme === 'light') {
    darkTheme.disabled = true
  }
</script>



<script defer crossorigin="anonymous" src="/blog/js/theme.js" integrity=""></script>

<script src="https://ixiaopan.github.io/blog/js/instantpage.min.js" type="module" defer></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css" integrity="sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG" crossorigin="anonymous">

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.js" integrity="sha384-JiKN5O8x9Hhs/UE5cT5AAJqieYlOZbGT3CHws/y97o3ty4R7/O5poG9F3JoiOYw1" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>

<script>
document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "$", right: "$", display: false}
        ]
    });
});
</script>

 



<meta name="generator" content="Hugo 0.91.0" />
  </head>
  <body>
    
  




<header>
  <nav class="navbar">
  <div class="nav">
    
      <a href="https://ixiaopan.github.io/blog/" class="nav-logo">
        <img
          src="https://ixiaopan.github.io/blog/images/me.JPG"
          width="50"
          height="50"
          alt="Logo"
        />
      </a>
    

    <ul class="nav-links">
      
        
          <li>
            <a href="/blog/search" id="Search"
              ><em class="fas fa-search fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/blog/about" id="About"
              ><em class="fas fa-user fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/blog/categories" id="Category"
              ><em class="fas fa-folder-open fa-lg"></em
            ></a>
          </li>
          
      
    </ul>
  </div>
</nav>


  
  <div class="intro-header">
    <h1 class="post-heading">
      数据压缩 101
    </h1>
    <span class="meta-post">
  <em class="fa fa-calendar-alt"></em
  >&nbsp;Oct 25, 2023
  
  &nbsp;&nbsp;<i class="fas fa-clock"></i>&nbsp;13 min read

  
    &nbsp;&nbsp;&nbsp;<em class="fa fa-folder-open"></em>&nbsp;
    
      <a
        href="https://ixiaopan.github.io/blog/categories/misc/"
        >Misc</a
      >&nbsp;
    
  
</span>

  </div>
  
</header>

    
  <div class="container" role="main">
    <div class="inner">
      <article class="article" class="blog-post">
        
  <p>前几天得闲随手翻了翻 <a href="https://book.douban.com/subject/35034359/">《数据压缩入门 - 豆瓣》</a>，内容是比较浅显，但是真的要深入理解并应用这些算法还是有一定难度，印象比较深刻的是这3个算法</p>
<ul>
<li>哈夫曼编码</li>
<li>算术编码</li>
<li>LZ编码</li>
</ul>
<p>在实际应用中，这几个算法也是经常结合使用的，比如 <code>gzip</code>。</p>
<h2 id="压缩思路">压缩思路</h2>
<ul>
<li>
<p>减少数据集中不同符号的数量，比如 <code>TO BE OR NOT TO BE</code> 如果按字符级别就有 <code>TOBERN</code> 6个符号，而按单词只有 <code>TO</code> <code>BE</code> <code>OR</code> <code>NOT</code> 4个，如果再按 <code>TO BE</code> <code>OR</code> <code>NOT</code> 只有3个</p>
</li>
<li>
<p>用更少的位数对更常见的符号进行编码，这个道理就显而易见的了</p>
</li>
</ul>
<p>但是也要考虑其他因素</p>
<ul>
<li>
<p>不同数据类型处理方法不同</p>
</li>
<li>
<p>有些数据需要转换才能压缩</p>
</li>
<li>
<p>数据可能是偏态的，比如温度夏天偏高冬天偏低</p>
</li>
</ul>
<h2 id="entropy">Entropy</h2>
<p>给定任意一个十进制整数，用二进制来表示这个数最少需要多少二进制位</p>
<p>$$
log_2(x) = ceil(log(x + 1) / log(2))
$$</p>
<p>这个值就是熵（entropy），扩展到整个数据集</p>
<p>$$
H(S) = - \sum_{i=1}^{n} p_i log_2(p_i)
$$</p>
<p>从上面的公式可以看出，</p>
<ul>
<li>熵是建立在对每个符号出现概率的估算之上的</li>
<li>熵表示的是数据集中的每个符号平均所需的最小二进制位数</li>
<li>一个符号出现得越频繁，$p_i$ 越大，熵越小，即越不重要</li>
</ul>
<p>有个在线计算 <a href="http://www.shannonentropy.netmark.pl">shannon entropy</a> 的网站，比如我们输入 <code>ABBCCCDDDD</code></p>
<p>首先会先计算频率
A: 0.1
B: 0.2
C: 0.3
D: 0.4</p>
<p>然后根据公示计算熵</p>
<p>$$
H(S) =  -[(0.1log_2 0.1)+(0.2log_2 0.2)+(0.3log_2 0.3)+(0.4log_2 0.4)] = 1.84644
$$</p>
<p>这个熵表示每个符号平均需要 <code>2bit</code> 表示，整个字符串也就是 <code>20bit</code></p>
<h3 id="突破熵">突破熵</h3>
<p>上面公式有个明显的问题 —— 只考虑了概率，忽略了数据本身含有的结构信息，比如顺序，语义等。比如[1,2,3,4]和 [3,2,1,4] 虽然熵一样，但是前者是线性递增序列，明显可以用更少的信息存储。</p>
<p>所以我们可以利用数据集的结构信息将其转换为一种新的表示形式，这也是突破熵的关键，可行的方法比如</p>
<ul>
<li>
<p>增量编码 delta coding：将数转换为与上一个数的差，比如 [0,1,2,3,4,5,6,7] 转换为[0,1,1,1,1,1,1,1]</p>
</li>
<li>
<p>字符分组</p>
</li>
</ul>
<h2 id="vlc">VLC</h2>
<p>需要寻找合适的码字，符合数据中符号的出现概率分布。</p>
<h3 id="前缀性质">前缀性质</h3>
<p>如何用 VLC 编码？</p>
<ul>
<li>
<p>计算数据集中每个符号的出现概率</p>
</li>
<li>
<p>根据概率为每个符号分配码字，一个符号出现的概率越大，所分配的码字就越短</p>
</li>
<li>
<p>再次遍历数据集，对每一个符号进行编码，并将对应的码字输出到压缩后的数据流中</p>
</li>
</ul>
<p>如何解码？</p>
<p>假设现在有如下编码 <code>A: 0, B: 10, C: 101, D: 111</code>，有待解码字符串 <code>0101111</code>，</p>
<p>首先 <code>0</code> 对应 <code>A</code>，然后 <code>1</code> 没有找到，继续得到 <code>10</code> 发现是 <code>B or C</code> 继续输入得 <code>101</code> 是 <code>C</code>，但是这里就有歧义了，<code>101</code> 是 <code>10</code> + <code>1</code> 即 <code>B+?</code> 还是就只是 <code>101</code> 即 <code>C</code></p>
<p>从这个例子可以看出，如果一个码字被分配了，就不能再用作另个码字的前缀，即码字需要满足 <code>前缀性质</code></p>
<h3 id="一元码">一元码</h3>
<p>任意正整数，<code>n</code>个  <code>1</code> 或 <code>0</code> 后面跟着一个 <code>0</code> 或者 <code>1</code>。比如</p>
<table>
<thead>
<tr>
<th>number</th>
<th>unary code</th>
<th>alternative</th>
<th>probability</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>10</td>
<td>01</td>
<td>0.5</td>
</tr>
<tr>
<td>2</td>
<td>110</td>
<td>001</td>
<td>0.25</td>
</tr>
<tr>
<td>3</td>
<td>1110</td>
<td>0001</td>
<td>0.125</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>本质就是有些位数 <code>1</code> 当作值来使用，而最后一位 <code>0</code> 作为分隔符使用</p>
</li>
<li>
<p>一元码满足前缀性质</p>
</li>
<li>
<p>但是对于大数字，比如 <code>1000</code> 那就是有 1000个1 加上 1个0，这就有点过犹不及了。</p>
</li>
</ul>
<h3 id="elias-gamma">Elias Gamma</h3>
<p>适用于无法确定上限的整数编码，分解 <code>x</code> 为2个因子，分别用一元码和二进制编码表示，同时为了保证可以无歧义的解码，二进制编码的长度是一元码的长度。</p>
<p>$$
x = 2^e + d
$$</p>
<p>举个例子， <code>42 = 2^5 + 10</code> 即一元码是 <code>111110</code>，二进制是 <code>1010</code>，合在一起就是 <code>111110:01010</code></p>
<p>cons</p>
<ul>
<li>因为使用了一元码，对于大数字，要经过位数很长的编码，比如1000要19个bit</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">egc</span>(<span style="color:#a6e22e">n</span>) {
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">u</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">floor</span>(Math.<span style="color:#a6e22e">log2</span>(<span style="color:#a6e22e">n</span>))
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">-</span> Math.<span style="color:#a6e22e">pow</span>(<span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">u</span>)
    
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">us</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Array(<span style="color:#a6e22e">u</span>).<span style="color:#a6e22e">fill</span>(<span style="color:#ae81ff">1</span>).<span style="color:#a6e22e">join</span>(<span style="color:#e6db74">&#39;&#39;</span>)
    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">bs</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">toString</span>(<span style="color:#ae81ff">2</span>)
    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">bs</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">us</span>.<span style="color:#a6e22e">length</span>) {
        <span style="color:#a6e22e">bs</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">bs</span>.<span style="color:#a6e22e">padStart</span>(<span style="color:#a6e22e">us</span>.<span style="color:#a6e22e">length</span>, <span style="color:#e6db74">&#39;0&#39;</span>)
    }
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;bit&#39;</span>, <span style="color:#a6e22e">us</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;0&#39;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">bs</span>)
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">us</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
}
</code></pre></div><p>举个例子，有如下数据 <code>10, 990, 21, 1</code></p>
<ul>
<li>
<p>如果使用固定编码，需要 <code>10bit * 4 = 40bit</code></p>
</li>
<li>
<p>使用 <code>Elias Gamma</code> 需要 <code>egc(10) + egc(990) + egc(21) + egc(1) = 36bit</code>，少了 <code>4bit</code></p>
</li>
</ul>
<h2 id="统计熵编码">统计/熵编码</h2>
<p>给定一个数据集，我们需要找到和符号出现概率匹配的VLC方法，从而为其分配码字，但不是每次都是这么走运，可能现有的 VLC 都不能满足。</p>
<p>可以使用统计编码解决，这类算法主要是根据符号出现的概率确定唯一的变长编码，这样任意数据集都有自己的一套自定义码字。</p>
<h3 id="哈夫曼编码">哈夫曼编码</h3>
<p><a href="https://www.programiz.com/dsa/huffman-coding">Huffman Coding</a> 其实就是构建一个二叉树</p>
<ul>
<li>
<p>每个符号都是叶子节点，所有其编码都满足前缀性质</p>
</li>
<li>
<p>因为是自底向上构建树，且是从权重最小(出现频次最小)的节点开始，那自然出现越频繁的节点路径越短，出现频率低的节点离根越远，整颗树自然也是加权路径最短，也是一颗最优二叉树</p>
</li>
</ul>
<p>Step 1 计算频率</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">calFreq</span>(<span style="color:#a6e22e">str</span>) {
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">freqTable</span> <span style="color:#f92672">=</span> {}
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">s</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">str</span>) {
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">freqTable</span>[<span style="color:#a6e22e">s</span>]) {
      <span style="color:#a6e22e">freqTable</span>[<span style="color:#a6e22e">s</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
    }
    <span style="color:#66d9ef">else</span> {
      <span style="color:#a6e22e">freqTable</span>[<span style="color:#a6e22e">s</span>] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
    }
  }
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">freqTable</span>
}
</code></pre></div><p>Step 2 Build Tree</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span> {
  <span style="color:#a6e22e">constructor</span>(<span style="color:#66d9ef">char</span>, <span style="color:#a6e22e">weight</span>) {
    <span style="color:#66d9ef">this</span>.<span style="color:#66d9ef">char</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">char</span>
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">weight</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">weight</span>
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">left</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>
  }
}

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">Huffman</span>(<span style="color:#a6e22e">str</span>) {
  <span style="color:#75715e">// building frequency table
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">freqTable</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">calFreq</span>(<span style="color:#a6e22e">str</span>)

  <span style="color:#75715e">// sorting &amp; creating leaf nodes
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">nodeList</span> <span style="color:#f92672">=</span> []
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">c</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">freqTable</span>) {
    <span style="color:#a6e22e">nodeList</span>.<span style="color:#a6e22e">push</span>(<span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Node</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">freqTable</span>[<span style="color:#a6e22e">c</span>]))
  }
  
  <span style="color:#75715e">// building tree
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">nodeList</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) {
    <span style="color:#a6e22e">nodeList</span>.<span style="color:#a6e22e">sort</span>((<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> ) =&gt; <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">weight</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">weight</span>)
    
    <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">l</span>, <span style="color:#a6e22e">r</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">nodeList</span>.<span style="color:#a6e22e">slice</span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>)
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">newNode</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Node</span>(<span style="color:#e6db74">&#39;&#39;</span>, <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">weight</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">weight</span>)
    <span style="color:#a6e22e">newNode</span>.<span style="color:#a6e22e">left</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">l</span>
    <span style="color:#a6e22e">newNode</span>.<span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">r</span>

    <span style="color:#a6e22e">nodeList</span>.<span style="color:#a6e22e">splice</span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">newNode</span>)
  }
  
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">nodeList</span>[<span style="color:#ae81ff">0</span>]
    
  <span style="color:#75715e">// const codings = {}
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// encode(nodeList[0], codings)
</span><span style="color:#75715e"></span>}
</code></pre></div><p>Step 3 encode</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">encode</span>(<span style="color:#a6e22e">node</span>, <span style="color:#a6e22e">coding</span>, <span style="color:#a6e22e">c</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;</span>) {
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">left</span> <span style="color:#f92672">||</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">right</span>) {
    <span style="color:#a6e22e">coding</span>[<span style="color:#a6e22e">node</span>.<span style="color:#66d9ef">char</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">c</span>
    <span style="color:#66d9ef">return</span>
  }
  
  <span style="color:#a6e22e">encode</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">coding</span>, <span style="color:#a6e22e">c</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;0&#39;</span>)
  <span style="color:#a6e22e">encode</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">right</span>, <span style="color:#a6e22e">coding</span>, <span style="color:#a6e22e">c</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;1&#39;</span>)
}
</code></pre></div><p>来看个实际例子</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">Huffman</span>(<span style="color:#e6db74">&#39;BCAADDDCCACACAC&#39;</span>)

<span style="color:#a6e22e">A</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;11&#34;</span>
<span style="color:#a6e22e">B</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;100&#34;</span>
<span style="color:#a6e22e">C</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;0&#34;</span>
<span style="color:#a6e22e">D</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;101&#34;</span>
</code></pre></div><h3 id="算术编码">算术编码</h3>
<p>这个算法的思想真是好有意思，具体可以参考 <a href="https://segmentfault.com/a/1190000011561822">算数编码原理解析</a>，写的很详细。</p>
<h2 id="字典转换">字典转换</h2>
<p>不同于统计压缩，字典转换是先识别出数据集中常见的单词/长字符串，而不是把每个字母作为一个符号，可以理解为字典转换是预处理阶段。</p>
<h3 id="如何找出正确单词">如何找出正确『单词』</h3>
<ul>
<li>正确的『单词』：最小熵的字符串</li>
<li>怎么识别是单词：分词 <code>tokenization</code></li>
</ul>
<h3 id="lz-算法">LZ 算法</h3>
<p>把数据中重复出现的长字符串加入字典，后续重复出现的字符串使用标记代替从而进行压缩。算法包括3个概念</p>
<ul>
<li>
<p>search buffer</p>
</li>
<li>
<p>look ahead buffer</p>
</li>
<li>
<p>sliding window</p>
</li>
</ul>
<p>具体参考 <a href="https://segmentfault.com/a/1190000011425787">LZW压缩算法原理解析</a>、<a href="https://blog.51cto.com/u_15127629/2873305">图解 LZ77 压缩算法</a>，我就懒得再写了。</p>
<p>pros</p>
<ul>
<li>解压很快，比较已经知道位置了</li>
</ul>
<p>cons</p>
<ul>
<li>压缩比较耗时，需要花时间在 search</li>
</ul>
<h2 id="contextual-transform">Contextual transform</h2>
<h3 id="run-length-encoding">run-length encoding</h3>
<p>对连续出现相同的符号进行聚类，比如 <code>AAAABBBBBBBBCCC</code> 输出为 <code>(4,A)(8, B),(3,C)</code></p>
<p>最坏情况，编码直接翻倍 <code>ABCD</code> 输出为 <code>(1,A)(1,B)(1,C)(1,D)</code></p>
<h3 id="delta-coding">delta coding</h3>
<p>将一组数据转换为各个相邻数据之间的相对差值（即增量）的过程。其思想是，给定一组数据，相关的或相似的数据往往会集中在一起。</p>
<p>最适用于处理时间序列数据（比如每10秒检测一次温度的传感器所产生的数据），以及音频和图像数据这类多媒体数据，因为这类数据中邻近的数据之间存在着时间上的关联</p>
<p>比如 <code>[1,3,6,8,10]</code> =&gt; <code>[1, 2,3,2,2]</code>，原先每个字符需要 4 bit，现在只要 2 bit</p>
<p>但是也可能存在负数比如 <code>[1,3,10,8,6]</code> =&gt; <code>[1,2,7,-2,-2]</code>，有很多改进方法</p>
<p>改进一：XOR 增量编码
<code>[1,3,10,8,6]</code> =&gt; <code>[1 xor 1, 1 xor 3, 3 xor 10, 10 xor 8, 6 xor 8]</code> =&gt; <code>[1,2,9,2,14]</code></p>
<p>改进二：参照系增量编码
<code>[107,108,110,115,120,125,132,132,131,135]</code> 每个数需要 8bit 存储，我们发现这些数都大于 107，所以让每个数都减去 107 就可以进行增量编码，即 <code>[0,1,3,8,13,18,25,25,24,28]</code> 这就只需要 5bit</p>
<h2 id="评价数据压缩">评价数据压缩</h2>
<h3 id="使用场景">使用场景</h3>
<ul>
<li>
<p>线下压缩、客户端解压</p>
<ul>
<li>比如游戏、app 等图片资源，压缩目的是使资源尽可能小</li>
</ul>
</li>
<li>
<p>客户端压缩、云端解压</p>
<ul>
<li>减少用户流量费用</li>
</ul>
</li>
<li>
<p>云端压缩、客户端解压</p>
<ul>
<li>case 1：比如服务器动态生成的数据，压缩目的是使减小网络传输</li>
<li>case 2：上传的图片转换为多种格式、大小的图片，上传的视频转为 H.264 等（阿里 oss 等都提供此服务），压缩目的可以高效的将大量数据压缩为最少的二进制位数</li>
</ul>
</li>
<li>
<p>客户端压缩、客户端解压</p>
</li>
</ul>
<h3 id="压缩的需求">压缩的需求</h3>
<ul>
<li>
<p>了解要处理的数据格式、类型、使用方式</p>
</li>
<li>
<p>了解各算法的指标</p>
</li>
<li>
<p>什么场景使用什么样的算法（比如缩略图我们会用有损压缩，而大图模式则使用高清无损图）</p>
</li>
</ul>
<h3 id="压缩率">压缩率</h3>
<p>压缩后大小和压缩前大小之比</p>
<h3 id="压缩性能">压缩性能</h3>
<p>将数据转换为压缩后的形式需要多长时间。在对网络延迟要求很高的情况下，无论是客户端还是服务端负责压，压缩性能都至关重要。考虑 2 个指标</p>
<ul>
<li>CPU</li>
<li>内存</li>
</ul>
<h3 id="解压性能">解压性能</h3>
<p>压缩率高不一定解压性能好，解压通常在客户端进行，但客户端存在内存小的问题；所以选择压缩算法，也要考虑其解压性能（这也和上面的压缩性能对应，本质还是要综合考虑硬件、CPU、内存等）</p>
<h2 id="与前端相关的压缩算法">与前端相关的压缩算法</h2>
<h3 id="图片压缩">图片压缩</h3>
<ul>
<li>PNG：无损压缩，支持 alpha</li>
<li>JPG：有损压缩，不支持 alpha</li>
<li>GIF：支持透明、支持动画，仅支持256色</li>
<li>WEBP：无损+透明度、有损</li>
</ul>
<p>一般是优先选择 <code>webp</code></p>
<h3 id="gzip">Gzip</h3>
<h3 id="brotli">Brotli</h3>
<h2 id="reference">Reference</h2>
<ul>
<li>
<p><a href="https://www.cnblogs.com/forfuture1978/p/3944583.html">Lucene 4.X 倒排索引原理与实现: (2) 倒排表的格式设计</a></p>
</li>
<li>
<p><a href="https://voskan.host/2023/01/29/huffman-data-compression-using-javascript/">Huffman Data Compression using JavaScript</a></p>
</li>
</ul>



        
      </article>

      
      <aside class="article-aside">
        <nav id="TableOfContents">
  <ul>
    <li><a href="#压缩思路">压缩思路</a></li>
    <li><a href="#entropy">Entropy</a>
      <ul>
        <li><a href="#突破熵">突破熵</a></li>
      </ul>
    </li>
    <li><a href="#vlc">VLC</a>
      <ul>
        <li><a href="#前缀性质">前缀性质</a></li>
        <li><a href="#一元码">一元码</a></li>
        <li><a href="#elias-gamma">Elias Gamma</a></li>
      </ul>
    </li>
    <li><a href="#统计熵编码">统计/熵编码</a>
      <ul>
        <li><a href="#哈夫曼编码">哈夫曼编码</a></li>
        <li><a href="#算术编码">算术编码</a></li>
      </ul>
    </li>
    <li><a href="#字典转换">字典转换</a>
      <ul>
        <li><a href="#如何找出正确单词">如何找出正确『单词』</a></li>
        <li><a href="#lz-算法">LZ 算法</a></li>
      </ul>
    </li>
    <li><a href="#contextual-transform">Contextual transform</a>
      <ul>
        <li><a href="#run-length-encoding">run-length encoding</a></li>
        <li><a href="#delta-coding">delta coding</a></li>
      </ul>
    </li>
    <li><a href="#评价数据压缩">评价数据压缩</a>
      <ul>
        <li><a href="#使用场景">使用场景</a></li>
        <li><a href="#压缩的需求">压缩的需求</a></li>
        <li><a href="#压缩率">压缩率</a></li>
        <li><a href="#压缩性能">压缩性能</a></li>
        <li><a href="#解压性能">解压性能</a></li>
      </ul>
    </li>
    <li><a href="#与前端相关的压缩算法">与前端相关的压缩算法</a>
      <ul>
        <li><a href="#图片压缩">图片压缩</a></li>
        <li><a href="#gzip">Gzip</a></li>
        <li><a href="#brotli">Brotli</a></li>
      </ul>
    </li>
    <li><a href="#reference">Reference</a></li>
  </ul>
</nav>
      
      </aside>
    </div>
    
    
    
    
      

    
  </div>

    <footer>
  

<div class="social-icons">
  
    
    
      
      <a href="mailto:?to=xiaopan.wpp@outlook.com" name="Email">
        <em class="fas fa-envelope"></em>
      </a>
    
       &nbsp;&nbsp;&nbsp;
      <a href="https://github.com/ixiaopan" name="GitHub">
        <em class="fab fa-github"></em>
      </a>
    
       &nbsp;&nbsp;&nbsp;
      <a href="https://www.linkedin.com/in/ixiaopan" name="Linkedin">
        <em class="fab fa-linkedin"></em>
      </a>
    
       &nbsp;&nbsp;&nbsp;
      <a href="https://space.bilibili.com/22910840" name="Bilibili">
        <em class="fab fa-youtube"></em>
      </a>
    
  

  
</div>


  
  <div class="container">
    <p class="credits copyright">
      <a href="https://ixiaopan.github.io/blog/about">ixiaopan</a>
      &nbsp;&copy;
      2023
      
      &nbsp;&ndash;&nbsp;
      <em class="fas fa-moon" id="dark-mode-toggle"></em>
    </p>

    <p class="credits theme-by">
      Powered By <a href="https://gohugo.io">Hugo</a>&nbsp;
      Theme
      <a href="https://github.com/matsuyoshi30/harbor">Harbor</a>
    </p>
  </div>
</footer>

  </body>
</html>
